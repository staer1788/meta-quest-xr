<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Meta Quest XR Model Viewer</title>
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.2.0/dist/aframe-extras.min.js"></script>
    <style>
      body { margin: 0; overflow: hidden; }
      #ui-container {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 9999;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 10px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        color: white;
        font-family: sans-serif;
      }
      #file-input-label {
        background-color: #007bff;
        color: white;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.3s ease;
      }
      #file-input-label:hover {
        background-color: #0056b3;
      }
      #file-input {
        display: none;
      }
      #status-message {
        margin-top: 5px;
        font-size: 14px;
        color: #f8d7da; /* Light red for errors */
      }
    </style>
  </head>
  <body>
    <a-scene
      webxr="requiredFeatures: hit-test, local-floor; optionalFeatures: dom-overlay; overlayElement: #ui-container;"
      renderer="colorManagement: true; antialias: true;"
      gltf-model="dracoDecoderPath: https://www.gstatic.com/draco/v1/decoders/;"
    >
      <!-- Camera and cursor -->
      <a-entity camera look-controls position="0 1.6 0">
        <a-entity
          cursor="rayOrigin: mouse"
          raycaster="objects: [gltf-model]; far: 100;"
          position="0 0 -1"
          geometry="primitive: ring; radiusOuter: 0.01; radiusInner: 0.005;"
          material="color: white; shader: flat;"
        ></a-entity>
      </a-entity>

      <!-- Default light -->
      <a-entity light="type: ambient; color: #BBB"></a-entity>
      <a-entity light="type: directional; color: #FFF; intensity: 0.6" position="-0.5 1 1"></a-entity>

      <!-- Ground for VR/AR -->
      <a-plane
        static-body
        rotation="-90 0 0"
        width="100"
        height="100"
        color="#7BC8A4"
        visible="false"
      ></a-plane>

      <!-- Placeholder for the 3D model -->
      <a-entity id="model-container"></a-entity>
    </a-scene>

    <div id="ui-container">
      <label id="file-input-label" for="file-input">3Dモデルをアップロード (GLB/glTF)</label>
      <input type="file" id="file-input" accept=".glb,.gltf" />
      <div id="status-message"></div>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const fileInput = document.getElementById('file-input');
        const modelContainer = document.getElementById('model-container');
        const statusMessage = document.getElementById('status-message');

        fileInput.addEventListener('change', (event) => {
          const file = event.target.files[0];
          if (!file) {
            return;
          }

          if (!file.name.endsWith('.glb') && !file.name.endsWith('.gltf')) {
            statusMessage.textContent = 'エラー: GLBまたはglTFファイルを選択してください。';
            statusMessage.style.color = '#f8d7da'; // Light red
            return;
          }

          statusMessage.textContent = 'モデルを読み込み中...';
          statusMessage.style.color = 'white';

          const reader = new FileReader();
          reader.onload = (e) => {
            const modelUrl = e.target.result;

            // Remove existing model if any
            while (modelContainer.firstChild) {
              modelContainer.removeChild(modelContainer.firstChild);
            }

            // Create new model entity
            const modelEntity = document.createElement('a-entity');
            modelEntity.setAttribute('gltf-model', modelUrl);
            modelEntity.setAttribute('scale', '1 1 1'); // Default scale, can be adjusted
            modelEntity.setAttribute('position', '0 1.6 -3'); // Position in front of the camera

            // Add a-frame-extras's animation-mixer for animations if present
            modelEntity.setAttribute('animation-mixer', '');

            // Add a-frame-extras's draggability and rotation for interaction
            modelEntity.setAttribute('grabbable', '');
            modelEntity.setAttribute('stretchable', '');
            modelEntity.setAttribute('droppable', '');
            modelEntity.setAttribute('rotation-controls', ''); // Custom component for rotation

            modelContainer.appendChild(modelEntity);

            modelEntity.addEventListener('model-loaded', () => {
              statusMessage.textContent = 'モデルが正常に読み込まれました。';
              statusMessage.style.color = '#d4edda'; // Light green
            });

            modelEntity.addEventListener('model-error', (error) => {
              statusMessage.textContent = `モデルの読み込み中にエラーが発生しました: ${error.detail.src}`;
              statusMessage.style.color = '#f8d7da'; // Light red
              console.error('Model loading error:', error);
            });
          };

          reader.onerror = (error) => {
            statusMessage.textContent = `ファイルの読み込み中にエラーが発生しました: ${error.message}`;
            statusMessage.style.color = '#f8d7da'; // Light red
            console.error('File reading error:', error);
          };

          reader.readAsDataURL(file);
        });

        // Custom component for rotation with mouse/touch
        AFRAME.registerComponent('rotation-controls', {
          init: function () {
            this.isRotating = false;
            this.lastX = 0;
            this.lastY = 0;

            this.onMouseDown = this.onMouseDown.bind(this);
            this.onMouseMove = this.onMouseMove.bind(this);
            this.onMouseUp = this.onMouseUp.bind(this);

            this.el.sceneEl.addEventListener('mousedown', this.onMouseDown);
            this.el.sceneEl.addEventListener('mousemove', this.onMouseMove);
            this.el.sceneEl.addEventListener('mouseup', this.onMouseUp);
          },

          onMouseDown: function (evt) {
            if (evt.button === 0) { // Left mouse button
              this.isRotating = true;
              this.lastX = evt.clientX;
              this.lastY = evt.clientY;
            }
          },

          onMouseMove: function (evt) {
            if (!this.isRotating) return;

            const deltaX = evt.clientX - this.lastX;
            const deltaY = evt.clientY - this.lastY;

            const rotation = this.el.getAttribute('rotation');
            const newY = rotation.y - deltaX * 0.2; // Adjust sensitivity
            const newX = rotation.x - deltaY * 0.2; // Adjust sensitivity

            this.el.setAttribute('rotation', { x: newX, y: newY, z: rotation.z });

            this.lastX = evt.clientX;
            this.lastY = evt.clientY;
          },

          onMouseUp: function () {
            this.isRotating = false;
          },

          remove: function () {
            this.el.sceneEl.removeEventListener('mousedown', this.onMouseDown);
            this.el.sceneEl.removeEventListener('mousemove', this.onMouseMove);
            this.el.sceneEl.removeEventListener('mouseup', this.onMouseUp);
          }
        });
      });
    </script>
  </body>
</html>
